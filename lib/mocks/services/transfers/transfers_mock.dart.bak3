/// Transfers Mock Implementation
///
/// Mock handlers for transfer endpoints.
library;

import 'package:dio/dio.dart';
import '../../base/api_contract.dart';
import '../../base/mock_data_generator.dart';
import '../../base/mock_interceptor.dart';
import '../auth/auth_mock.dart';

/// Transfers mock state
class TransfersMockState {
  static final List<Map<String, dynamic>> transfers = [];

  static void reset() {
    transfers.clear();
  }

  /// Add a transfer
  static Map<String, dynamic> createTransfer({
    required String type,
    required String recipientPhone,
    required double amount,
    String? note,
  }) {
    final transfer = {
      'id': MockDataGenerator.uuid(),
      'reference': MockDataGenerator.transactionRef(),
      'type': type,
      'status': 'completed',
      'amount': amount,
      'fee': 0.0,
      'currency': 'USDC',
      'recipientPhone': recipientPhone,
      'note': note,
      'createdAt': DateTime.now().toIso8601String(),
      'updatedAt': DateTime.now().toIso8601String(),
    };

    transfers.add(transfer);
    return transfer;
  }

  /// Get recent transfers
  static List<Map<String, dynamic>> getRecentTransfers({
    int limit = 10,
    String? type,
  }) {
    var filtered = transfers;
    if (type != null) {
      filtered = transfers.where((t) => t['type'] == type).toList();
    }
    return filtered.take(limit).toList();
  }
}

class TransfersMock {
  static void register(MockInterceptor interceptor) {
    // POST /transfers/internal - Internal transfer
    interceptor.register(
      method: 'POST',
      path: '/transfers/internal',
      handler: _handleInternalTransfer,
    );

    // POST /transfers/external - External transfer
    interceptor.register(
      method: 'POST',
      path: '/transfers/external',
      handler: _handleExternalTransfer,
    );

    // GET /transfers - Get transfers
    interceptor.register(
      method: 'GET',
      path: r'/transfers$',
      handler: _handleGetTransfers,
    );

    // GET /transfers/:id - Get transfer by ID
    interceptor.register(
      method: 'GET',
      path: r'/transfers/[\w-]+',
      handler: _handleGetTransferById,
    );
  }

  /// Check PIN verification header
  /// Returns error response if PIN token is missing or invalid
  static MockResponse? _checkPinVerification(RequestOptions options) {
    // Check if user is authenticated first
    final userId = AuthMockState.currentUserId;
    if (userId == null) {
      return MockResponse.unauthorized('Not authenticated');
    }

    // Get PIN token from header
    final pinToken = options.headers['X-Pin-Token'] ??
                     options.headers['x-pin-token'];

    if (pinToken == null || (pinToken is String && pinToken.isEmpty)) {
      return MockResponse(
        statusCode: 400,
        errorMessage: 'PIN verification required for this operation',
        data: {
          'message': 'PIN verification required for this operation',
          'code': 'PIN_REQUIRED',
          'hint': 'Call POST /wallet/pin/verify first, then include the returned token in X-Pin-Token header',
        },
      );
    }

    // Validate token format (should be a hex string from mock PIN verify)
    final tokenStr = pinToken.toString();
    if (tokenStr.isEmpty || (!tokenStr.startsWith('mock_pin_token_') && tokenStr.length < 16)) {
      return MockResponse(
        statusCode: 403,
        errorMessage: 'Invalid or expired PIN verification',
        data: {
          'message': 'Invalid or expired PIN verification',
          'code': 'PIN_INVALID',
          'hint': 'PIN verification has expired. Please verify your PIN again.',
        },
      );
    }

    // PIN verification passed
    return null;
  }

  /// Handle internal transfer
  static Future<MockResponse> _handleInternalTransfer(RequestOptions options) async {
    // Check PIN verification first
    final pinCheckResult = _checkPinVerification(options);
    if (pinCheckResult != null) {
      return pinCheckResult;
    }

    final data = options.data as Map<String, dynamic>;
    final recipientPhone = data['recipientPhone'] as String;
    final amount = (data['amount'] as num).toDouble();
    final note = data['note'] as String?;

    // Validate
    if (recipientPhone.isEmpty) {
      return MockResponse.badRequest('Recipient phone is required');
    }

    if (amount <= 0) {
      return MockResponse.badRequest('Amount must be greater than 0');
    }

    // Create transfer
    final transfer = TransfersMockState.createTransfer(
      type: 'internal',
      recipientPhone: recipientPhone,
      amount: amount,
      note: note,
    );

    return MockResponse.success(transfer);
  }

  /// Handle external transfer
  static Future<MockResponse> _handleExternalTransfer(RequestOptions options) async {
    // Check PIN verification first
    final pinCheckResult = _checkPinVerification(options);
    if (pinCheckResult != null) {
      return pinCheckResult;
    }

    final data = options.data as Map<String, dynamic>;
    final recipientAddress = data['recipientAddress'] as String;
    final amount = (data['amount'] as num).toDouble();
    final blockchain = data['blockchain'] as String?;
    final note = data['note'] as String?;

    // Validate
    if (recipientAddress.isEmpty) {
      return MockResponse.badRequest('Recipient address is required');
    }

    if (amount <= 0) {
      return MockResponse.badRequest('Amount must be greater than 0');
    }

    // Create transfer
    final transfer = {
      'id': MockDataGenerator.uuid(),
      'reference': MockDataGenerator.transactionRef(),
      'type': 'external',
      'status': 'pending',
      'amount': amount,
      'fee': amount * 0.005, // 0.5% fee
      'currency': 'USDC',
      'recipientAddress': recipientAddress,
      'blockchain': blockchain ?? 'polygon',
      'note': note,
      'txHash': '0x${MockDataGenerator.uuid().replaceAll('-', '')}',
      'createdAt': DateTime.now().toIso8601String(),
      'updatedAt': DateTime.now().toIso8601String(),
    };

    TransfersMockState.transfers.add(transfer);

    return MockResponse.success(transfer);
  }

  /// Handle get transfers
  static Future<MockResponse> _handleGetTransfers(RequestOptions options) async {
    final userId = AuthMockState.currentUserId;
    if (userId == null) {
      return MockResponse.unauthorized('Not authenticated');
    }

    final queryParams = options.queryParameters;
    final page = int.tryParse(queryParams['page']?.toString() ?? '1') ?? 1;
    final pageSize =
        int.tryParse(queryParams['pageSize']?.toString() ?? '20') ?? 20;
    final type = queryParams['type'] as String?;

    final transfers = TransfersMockState.getRecentTransfers(
      limit: pageSize,
      type: type,
    );

    return MockResponse.success({
      'items': transfers,
      'total': transfers.length,
      'page': page,
      'pageSize': pageSize,
      'totalPages': (transfers.length / pageSize).ceil(),
    });
  }

  /// Handle get transfer by ID
  static Future<MockResponse> _handleGetTransferById(RequestOptions options) async {
    final userId = AuthMockState.currentUserId;
    if (userId == null) {
      return MockResponse.unauthorized('Not authenticated');
    }

    final id = options.path.split('/').last;
    final transfer = TransfersMockState.transfers.firstWhere(
      (t) => t['id'] == id,
      orElse: () => {},
    );

    if (transfer.isEmpty) {
      return MockResponse.notFound('Transfer not found');
    }

    return MockResponse.success(transfer);
  }
}
